// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by tool/doctest.dart from markdown documentation
//
// ignore_for_file: unused_local_variable, unused_import
// ignore_for_file: avoid_print, unnecessary_string_interpolations

@Timeout(Duration(seconds: 600))
library;

import "dart:io";
import 'dart:io';
import 'dart:math' as math;
import 'dart:typed_data';
import 'package:nobodywho/nobodywho.dart' as nobodywho;
import 'package:test/test.dart';

void main() {
  group('Doctest: Flutter Docs', () {
    setUpAll(() async {
      // Create symlinks for model paths used in docs
      final modelPath = Platform.environment['TEST_MODEL'];
      final embeddingPath = Platform.environment['TEST_EMBEDDINGS_MODEL'];
      final rerankerPath = Platform.environment['TEST_CROSSENCODER_MODEL'];

      if (modelPath != null && !File('./model.gguf').existsSync()) {
        Link('./model.gguf').createSync(modelPath);
      }
      if (embeddingPath != null && !File('./embedding-model.gguf').existsSync()) {
        Link('./embedding-model.gguf').createSync(embeddingPath);
      }
      if (rerankerPath != null && !File('./reranker-model.gguf').existsSync()) {
        Link('./reranker-model.gguf').createSync(rerankerPath);
      }
    });

    tearDownAll(() async {
      // Clean up symlinks
      final links = ['./model.gguf', './embedding-model.gguf', './reranker-model.gguf'];
      for (final path in links) {
        final link = Link(path);
        if (link.existsSync()) {
          link.deleteSync();
        }
      }
    });

    test('index.md:16', () async {
      
    });

    test('index.md:23', () async {
      await nobodywho.NobodyWho.init();
    });

    test('tool-calling.md:21', () async {
      final circleAreaTool = nobodywho.Tool(
        name: "circle_area",
        description: "Calculates the area of a circle given its radius",
        function: ({ required double radius }) {
          final area = math.pi * radius * radius;
          return "Circle with radius $radius has area ${area.toStringAsFixed(2)}";
        }
      );
    });

    test('tool-calling.md:50', () async {
      final getCurrentDirTool = nobodywho.Tool(
        name: "get_current_dir",
        description: "Gets path of the current directory",
        function: () => Directory.current.path
      );
      
      final listFilesTool = nobodywho.Tool(
        name: "list_files",
        description: "Lists files in the given directory.",
        function: ({required String path}) {
          final dir = Directory(path);
          final files = dir.listSync()
              .where((entity) => entity is File)
              .map((file) => file.path.split('/').last)
              .toList();
          return "Files: ${files.join(', ')}";
        },
        parameterDescriptions : {"path" : "The path to directory you want list. Must be a valid path." }
      );
      
      final getFileSizeTool = nobodywho.Tool(
        name: "get_file_size",
        description: "Gets the size of a file in bytes.",
        function: ({required String filepath}) async {
          final file = File(filepath);
          final size = await file.length();
          return "File size: $size bytes";
        },
        parameterDescriptions : {"filepath" : "The path to file you wish to know the size of. Must be a valid path." }
      );
      
      final chat = await nobodywho.Chat.fromPath(
        modelPath: './model.gguf',
        tools: [getCurrentDirTool, listFilesTool, getFileSizeTool],
        templateVariables: {"enable_thinking": false}
      );
      
      final response = await chat.ask('What is the biggest file in my current directory?').completed();
      print(response); // The largest file in your current directory is `model.gguf`.
    });

    test('embeddings-and-rag.md:22', () async {
      final encoder = await nobodywho.Encoder.fromPath(modelPath: './embedding-model.gguf');
      final embedding = await encoder.encode(text: "What is the weather like?");
      print("Vector with ${embedding.length} dimensions");
    });

    test('embeddings-and-rag.md:36', () async {
      final encoder = await nobodywho.Encoder.fromPath(modelPath: './embedding-model.gguf');
      
      final query = await encoder.encode(text: "How do I reset my password?");
      final doc1 = await encoder.encode(text: "You can reset your password in the account settings");
      final doc2 = await encoder.encode(text: "The password requirements include 8 characters minimum");
      
      final similarity1 = nobodywho.cosineSimilarity(
        a: query.toList(),
        b: doc1.toList()
      );
      final similarity2 = nobodywho.cosineSimilarity(
        a: query.toList(),
        b: doc2.toList()
      );
      
      print("Document 1 similarity: ${similarity1.toStringAsFixed(3)}");  // Higher score
      print("Document 2 similarity: ${similarity2.toStringAsFixed(3)}");  // Lower score
    });

    test('embeddings-and-rag.md:63', () async {
      final encoder = await nobodywho.Encoder.fromPath(modelPath: './embedding-model.gguf');
      
      // Your knowledge base
      final documents = [
        "Python supports multiple programming paradigms including object-oriented and functional",
        "JavaScript is primarily used for web development and runs in browsers",
        "SQL is a domain-specific language for managing relational databases",
        "Git is a version control system for tracking changes in source code"
      ];
      
      // Pre-compute document embeddings
      final docEmbeddings = <Float32List>[];
      for (final doc in documents) {
        docEmbeddings.add(await encoder.encode(text: doc));
      }
      
      // Search query
      final query = "What language should I use for database queries?";
      final queryEmbedding = await encoder.encode(text: query);
      
      // Find the most relevant document
      double maxSimilarity = -1;
      int bestIdx = 0;
      for (int i = 0; i < docEmbeddings.length; i++) {
        final similarity = nobodywho.cosineSimilarity(
          a: queryEmbedding.toList(),
          b: docEmbeddings[i].toList()
        );
        if (similarity > maxSimilarity) {
          maxSimilarity = similarity;
          bestIdx = i;
        }
      }
      
      print("Most relevant: ${documents[bestIdx]}");
      print("Similarity score: ${maxSimilarity.toStringAsFixed(3)}");
    });

    test('embeddings-and-rag.md:128', () async {
      // Download a reranking model like bge-reranker-v2-m3-Q8_0.gguf
      final crossencoder = await nobodywho.CrossEncoder.fromPath(modelPath: './reranker-model.gguf');
      
      final query = "How do I install Python packages?";
      final documents = [
        "Someone previously asked about Python packages",
        "Use pip install package-name to install Python packages",
        "Python packages are not included in the standard library"
      ];
      
      // Get relevance scores for each document
      final scores = await crossencoder.rank(query: query, documents: documents);
      print(scores);  // [0.23, 0.89, 0.45] - second doc scores highest
      // Returns list of (document, score) tuples, sorted by score
      final rankedDocs = await crossencoder.rankAndSort(query: query, documents: documents);
      
      for (final (doc, score) in rankedDocs) {
        print("[${score.toStringAsFixed(3)}] $doc");
      }
    });

    test('embeddings-and-rag.md:167', () async {
      await _doctest_8();
    });

    test('embeddings-and-rag.md:216', () async {
      await _doctest_9();
    });

    test('embeddings-and-rag.md:263', () async {
      // For longer documents, increase context size
      final encoder = await nobodywho.Encoder.fromPath(modelPath: './embedding-model.gguf');
      
      final crossencoder = await nobodywho.CrossEncoder.fromPath(modelPath: './reranker-model.gguf');
    });

    test('sampling.md:15', () async {
      final chat = await nobodywho.Chat.fromPath(
        modelPath: "./model.gguf",
        sampler: nobodywho.SamplerPresets.temperature(temperature: 0.2)
      );
    });

    test('sampling.md:46', () async {
      final chat = await nobodywho.Chat.fromPath(
        modelPath: './model.gguf',
        sampler: nobodywho.SamplerPresets.json()
      );
    });

    test('sampling.md:54', () async {
      final sampler = nobodywho.SamplerPresets.grammar(grammar: """
          file ::= record (newline record)* newline?
          record ::= field ("," field)*
          field ::= quoted_field | unquoted_field
          unquoted_field ::= unquoted_char*
          unquoted_char ::= [^,"\n\r]
          quoted_field ::= "\"" quoted_char* "\""
          quoted_char ::= [^"] | "\"\""
          newline ::= "\r\n" | "\n"
      """);
    });

    test('sampling.md:75', () async {
      final chat = await nobodywho.Chat.fromPath(
        modelPath: "./model.gguf",
        sampler: nobodywho.SamplerBuilder()
            .temperature(temperature: 0.8)
            .topK(topK: 5)
            .dist()
      );
      final sampler = nobodywho.SamplerBuilder()
          .temperature(temperature: 0.8)
          .topK(topK: 5)
          .dist();
      
      await chat.setSamplerConfig(sampler);
    });

    test('chat.md:17', () async {
      final chat = await nobodywho.Chat.fromPath(modelPath: "./model.gguf");
    });

    test('chat.md:23', () async {
      final model = await nobodywho.Model.load(modelPath: "./model.gguf");
      final chat = nobodywho.Chat(model : model);
    });

    test('chat.md:34', () async {
      final chat = await nobodywho.Chat.fromPath(modelPath: "./model.gguf");
      final response = await chat.ask("Is water wet?");
      await for (final token in response) {
         stdout.write(token);
         await stdout.flush();
      }
      print("\n");
      final fullResponse = await response.completed();
      final msgs = await chat.getChatHistory();
      print(msgs[0].content); // "Is water wet?"
      await chat.setChatHistory([
        nobodywho.Message.message(role: nobodywho.Role.user, content: "What is water?")
      ]);
    });

    test('chat.md:85', () async {
      final chat = await nobodywho.Chat.fromPath(
        modelPath: "./model.gguf",
        systemPrompt: "You are a mischievous assistant!"
      );
    });

    test('chat.md:101', () async {
      final chat = await nobodywho.Chat.fromPath(
        modelPath: "./model.gguf",
        contextSize: 4096
      );
      await chat.resetContext(systemPrompt: "New system prompt", tools: []);
    });

    test('chat.md:140', () async {
      final model = await nobodywho.Model.load(modelPath: './model.gguf', useGpu: true);
    });

    test('chat.md:144', () async {
      final chat = await nobodywho.Chat.fromPath(modelPath: './model.gguf', useGpu : false);
    });

    test('chat.md:154', () async {
      final chat = await nobodywho.Chat.fromPath(
        modelPath: "./model.gguf",
        templateVariables: {"enable_thinking": true}
      );
      await chat.setTemplateVariable("enable_thinking", true);
    });

  });
}

// Extracted from embeddings-and-rag.md:167
Future<void> _doctest_8() async {
  // Initialize the cross-encoder for document ranking
  final crossencoder = await nobodywho.CrossEncoder.fromPath(modelPath: './reranker-model.gguf');

  // Your knowledge base
  final knowledge = [
    "Our company offers a 30-day return policy for all products",
    "Free shipping is available on orders over \$50",
    "Customer support is available via email and phone",
    "We accept credit cards, PayPal, and bank transfers",
    "Order tracking is available through your account dashboard"
  ];

  // Create a tool that searches the knowledge base
  final searchKnowledgeTool = nobodywho.Tool(
    function: ({required String query}) async {
      // Rank all documents by relevance to the query
      final ranked = await crossencoder.rankAndSort(query: query, documents: knowledge);
      
      // Return top 3 most relevant documents
      final topDocs = ranked.take(3).map((e) => e.$1).toList();
      return topDocs.join("\n");
    },
    name: "search_knowledge",
    description: "Search the knowledge base for relevant information"
  );

  // Create a chat with access to the knowledge base
  final chat = await nobodywho.Chat.fromPath(
    modelPath: './model.gguf',
    systemPrompt: "You are a customer service assistant. Use the search_knowledge tool to find relevant information from our policies before answering customer questions.",
    tools: [searchKnowledgeTool]
  );

  // The chat will automatically search the knowledge base when needed
  final response = await chat.ask("What is your return policy?").completed();
  print(response);
}

// Extracted from embeddings-and-rag.md:216
Future<void> _doctest_9() async {
  final encoder = await nobodywho.Encoder.fromPath(modelPath: './embedding-model.gguf');
  
  final crossencoder = await nobodywho.CrossEncoder.fromPath(modelPath: './reranker-model.gguf');
  
  // Generate embeddings asynchronously
  final embedding = await encoder.encode(text: "What is the weather?");
  
  // Rank documents asynchronously
  final query = "What is our refund policy?";
  final docs = [
    "Refunds processed within 5-7 business days",
    "No refunds on sale items",
    "Contact support to initiate refund"
  ];
  final ranked = await crossencoder.rankAndSort(query: query, documents: docs);
  
  for (final (doc, score) in ranked) {
    print("[${score.toStringAsFixed(3)}] $doc");
  }
}
