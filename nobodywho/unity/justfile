# Unity Development Tasks
set shell := ["bash", "-c"]
set dotenv-load := true

# Cache configuration
CACHE_DIR := ".temp-project-cache"
PROJECT_CACHE := CACHE_DIR + "/project-template"
MODEL_CACHE := CACHE_DIR + "/models"
PACKAGE_CACHE := CACHE_DIR + "/packages"
TEMP_PROJECT := "temp-project"
MODEL_FILENAME := "qwen2.5-1.5b-instruct-q4_0.gguf"
MODEL_URL := "https://huggingface.co/Qwen/Qwen2.5-1.5B-Instruct-GGUF/resolve/main/qwen2.5-1.5b-instruct-q4_0.gguf"

default:
    just test

_ensure-cache-dirs:
    mkdir -p "{{PROJECT_CACHE}}" "{{MODEL_CACHE}}" "{{PACKAGE_CACHE}}"

_ensure-license:
    #!/usr/bin/env bash
    LICENSE_PATH=~/.local/share/unity3d/Unity/Unity_lic.ulf
    
    if [ ! -f "$LICENSE_PATH" ]; then
        echo "🔑 No Unity license found at $LICENSE_PATH"
        echo ""
        echo "Please follow these steps:"
        echo "1. Run: unityhub"
        echo "2. Log in with your Unity account"
        echo "3. Go to Preferences > Licenses"
        echo "4. Click Add > Get a free personal license"
        echo ""
        echo "The license file will be created automatically at:"
        echo "$LICENSE_PATH"
        echo ""
        echo "Then run 'just' again to launch Unity"
        exit 1
    fi

_hash-source-files:
    #!/usr/bin/env bash
    find src -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1

_ensure-temp-project: _ensure-license
    #!/usr/bin/env bash
    # Check if temp project already exists
    if [ -d "{{TEMP_PROJECT}}" ]; then
        # Update source files only
        mkdir -p "{{TEMP_PROJECT}}/Packages/com.nobodywho.core"
        cp -r src/* "{{TEMP_PROJECT}}/Packages/com.nobodywho.core/"
        echo "✅ Updated source files in existing project"
        exit 0
    fi

    echo "🔨 Creating new project..."
    # Create fresh project
    unity-editor \
        -batchmode \
        -createProject "{{TEMP_PROJECT}}" \
        -quit
        
    # Install test framework
    unity-editor \
        -batchmode \
        -projectPath "{{TEMP_PROJECT}}" \
        -addPackage "com.unity.test-framework@1.4.5" \
        -quit
    
    # Copy source files
    mkdir -p "{{TEMP_PROJECT}}/Packages/com.nobodywho.core"
    cp -r src/* "{{TEMP_PROJECT}}/Packages/com.nobodywho.core/"
    
    # Ensure model exists
    STREAMING_ASSETS="{{TEMP_PROJECT}}/Assets/StreamingAssets"
    mkdir -p "$STREAMING_ASSETS"
    if [ ! -f "$STREAMING_ASSETS/{{MODEL_FILENAME}}" ]; then
        echo "📥 Downloading model..."
        curl -L --fail --progress-bar "{{MODEL_URL}}" -o "$STREAMING_ASSETS/{{MODEL_FILENAME}}"
    fi
    
    echo "✅ Temporary project ready at: {{TEMP_PROJECT}}"

# Clean all caches and temporary files
clean-all:
    rm -rf "{{TEMP_PROJECT}}"
    rm -rf "{{CACHE_DIR}}"

build-plugin:
    #!/usr/bin/env bash
    cargo build
    mkdir -p ./src/Runtime/Plugins/x86_64
    cp "../target/debug/libunity_plugin.so" "./src/Runtime/Plugins/x86_64/libnobodywho.so"
    
    echo "✅ Build complete!"

run-unity: _ensure-temp-project
    #!/usr/bin/env bash
    echo "🚀 Running Unity..."
    unity-editor -projectPath "{{TEMP_PROJECT}}"

test VERBOSE="false": _ensure-temp-project build-plugin
    #!/usr/bin/env bash
    echo "🚀 Running Unity tests..."

    # Start Unity in background and stream its log
    unity-editor \
        -projectPath "{{TEMP_PROJECT}}" \
        -batchmode \
        -runTests \
        -testResults "$(pwd)/test-results.xml" \
        -testPlatform PlayMode \
        -logFile "$(pwd)/unity-test.log" &
    
    UNITY_PID=$!

    # stream the logs while unity is running
    tail -f unity-test.log &
    TAIL_PID=$!

    wait $UNITY_PID
    UNITY_EXIT_CODE=$?
    
    kill $TAIL_PID
    echo "Unity exited with code: $UNITY_EXIT_CODE"
    
    TEST_RESULT=0
    just _parse-result || TEST_RESULT=$?
    
    rm -rf "$(pwd)/unity-test.log"
    rm -rf "$(pwd)/test-results.xml"
    exit $TEST_RESULT

_parse-result:
    #!/usr/bin/env bash
    # Get test results if they exist
    if [ -f "$(pwd)/test-results.xml" ]; then
        RESULTS=$(just _parse-test-results)
        IFS=':' read -r TOTAL PASSED FAILED SKIPPED DURATION <<< "$RESULTS"
        
        echo ""
        echo "📊 Test Results Summary:"
        echo "===================="
        
        # Display summary
        echo "✨ Total Tests: $TOTAL"
        echo "✅ Passed: $PASSED"
        echo "❌ Failed: $FAILED"
        echo "⏱️  Duration: $DURATION seconds"
        echo ""
        
        # If there are failures, show them
        if [ "$FAILED" -gt 0 ]; then
            echo "Failed Tests:"
            echo "============"
            echo ""
            
            # Get all failed test names
            FAILED_TESTS=$(xmllint --xpath "//test-case[@result='Failed']/@name" test-results.xml 2>/dev/null | tr ' ' '\n' | sed 's/name="\(.*\)"/\1/')
            
            # For each failed test, get its message
            echo "$FAILED_TESTS" | while IFS= read -r test_name; do
                if [ ! -z "$test_name" ]; then
                    # Get the failure message for this test
                    message=$(xmllint --xpath "string(//test-case[@name='$test_name']//failure/message)" test-results.xml 2>/dev/null | sed 's/\[\[CDATA\[\(.*\)\]\]\>/\1/')
                    
                    echo "❌ $test_name"
                    echo "-------------------"
                    echo "$message"
                    echo ""
                fi
            done
        fi
        
        # Return status code based on test results
        if [ "$FAILED" -gt 0 ]; then
            exit 1
        else
            exit 0
        fi
    else
        echo "❌ No test results XML file was generated"
        exit 1
    fi

_parse-test-results:
    #!/usr/bin/env bash
    if [ ! -f "test-results.xml" ]; then
        echo "❌ No test results found!"
        exit 1
    fi
    
    # Parse the XML file using xmllint with default values if not found
    TOTAL=$(xmllint --xpath "string(/test-run/@total)" test-results.xml 2>/dev/null || echo "0")
    PASSED=$(xmllint --xpath "string(/test-run/@passed)" test-results.xml 2>/dev/null || echo "0")
    FAILED=$(xmllint --xpath "string(/test-run/@failed)" test-results.xml 2>/dev/null || echo "0")
    SKIPPED=$(xmllint --xpath "string(/test-run/@skipped)" test-results.xml 2>/dev/null || echo "0")
    DURATION=$(xmllint --xpath "string(/test-run/@duration)" test-results.xml 2>/dev/null || echo "0")
    
    # Convert empty strings to 0
    TOTAL=${TOTAL:-0}
    PASSED=${PASSED:-0}
    FAILED=${FAILED:-0}
    SKIPPED=${SKIPPED:-0}
    DURATION=${DURATION:-0}
    
    # Output in a format that can be captured
    echo "$TOTAL:$PASSED:$FAILED:$SKIPPED:$DURATION"

